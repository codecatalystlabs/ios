// Package models contains generated code for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Admission represents a row from 'public.admission'.
type Admission struct {
	ID            int            `json:"id"`             // id
	EncounterID   sql.NullInt64  `json:"encounter_id"`   // encounter_id
	Admitted      sql.NullInt64  `json:"admitted"`       // admitted
	AdmissionDate sql.NullTime   `json:"admission_date"` // admission_date
	DischargeDate sql.NullTime   `json:"discharge_date"` // discharge_date
	Remark        sql.NullString `json:"remark"`         // remark
	EnterBy       sql.NullInt64  `json:"enter_by"`       // enter_by
	EnterOn       sql.NullTime   `json:"enter_on"`       // enter_on
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Admission] exists in the database.
func (a *Admission) Exists() bool {
	return a._exists
}

// Deleted returns true when the [Admission] has been marked for deletion
// from the database.
func (a *Admission) Deleted() bool {
	return a._deleted
}

// Insert inserts the [Admission] to the database.
func (a *Admission) Insert(ctx context.Context, db DB) error {
	switch {
	case a._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case a._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.admission (` +
		`encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING id`
	// run
	logf(sqlstr, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn)
	if err := db.QueryRowContext(ctx, sqlstr, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn).Scan(&a.ID); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Update updates a [Admission] in the database.
func (a *Admission) Update(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case a._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.admission SET ` +
		`encounter_id = $1, admitted = $2, admission_date = $3, discharge_date = $4, remark = $5, enter_by = $6, enter_on = $7 ` +
		`WHERE id = $8`
	// run
	logf(sqlstr, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn, a.ID)
	if _, err := db.ExecContext(ctx, sqlstr, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn, a.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Admission] to the database.
func (a *Admission) Save(ctx context.Context, db DB) error {
	if a.Exists() {
		return a.Update(ctx, db)
	}
	return a.Insert(ctx, db)
}

// Upsert performs an upsert for [Admission].
func (a *Admission) Upsert(ctx context.Context, db DB) error {
	switch {
	case a._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.admission (` +
		`id, encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`encounter_id = EXCLUDED.encounter_id, admitted = EXCLUDED.admitted, admission_date = EXCLUDED.admission_date, discharge_date = EXCLUDED.discharge_date, remark = EXCLUDED.remark, enter_by = EXCLUDED.enter_by, enter_on = EXCLUDED.enter_on `
	// run
	logf(sqlstr, a.ID, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn)
	if _, err := db.ExecContext(ctx, sqlstr, a.ID, a.EncounterID, a.Admitted, a.AdmissionDate, a.DischargeDate, a.Remark, a.EnterBy, a.EnterOn); err != nil {
		return logerror(err)
	}
	// set exists
	a._exists = true
	return nil
}

// Delete deletes the [Admission] from the database.
func (a *Admission) Delete(ctx context.Context, db DB) error {
	switch {
	case !a._exists: // doesn't exist
		return nil
	case a._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.admission ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, a.ID)
	if _, err := db.ExecContext(ctx, sqlstr, a.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	a._deleted = true
	return nil
}

// AdmissionByID retrieves a row from 'public.admission' as a [Admission].
//
// Generated from index 'admission_pkey'.
func AdmissionByID(ctx context.Context, db DB, id int) (*Admission, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on ` +
		`FROM public.admission ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	a := Admission{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&a.ID, &a.EncounterID, &a.Admitted, &a.AdmissionDate, &a.DischargeDate, &a.Remark, &a.EnterBy, &a.EnterOn); err != nil {
		return nil, logerror(err)
	}
	return &a, nil
}
