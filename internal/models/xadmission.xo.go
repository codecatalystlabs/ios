package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// XAdmission represents a row from 'public.x_admission'.
type XAdmission struct {
	ID            int            `json:"id"`             // id
	EncounterID   sql.NullInt64  `json:"encounter_id"`   // encounter_id
	Admitted      sql.NullInt64  `json:"admitted"`       // admitted
	AdmissionDate sql.NullTime   `json:"admission_date"` // admission_date
	DischargeDate sql.NullTime   `json:"discharge_date"` // discharge_date
	Remark        sql.NullString `json:"remark"`         // remark
	EnterBy       sql.NullInt64  `json:"enter_by"`       // enter_by
	EnterOn       sql.NullTime   `json:"enter_on"`       // enter_on
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [XAdmission] exists in the database.
func (xa *XAdmission) Exists() bool {
	return xa._exists
}

// Deleted returns true when the [XAdmission] has been marked for deletion
// from the database.
func (xa *XAdmission) Deleted() bool {
	return xa._deleted
}

// Insert inserts the [XAdmission] to the database.
func (xa *XAdmission) Insert(ctx context.Context, db DB) error {
	switch {
	case xa._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case xa._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.x_admission (` +
		`encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING id`
	// run
	logf(sqlstr, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn)
	if err := db.QueryRowContext(ctx, sqlstr, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn).Scan(&xa.ID); err != nil {
		return logerror(err)
	}
	// set exists
	xa._exists = true
	return nil
}

// Update updates a [XAdmission] in the database.
func (xa *XAdmission) Update(ctx context.Context, db DB) error {
	switch {
	case !xa._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case xa._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.x_admission SET ` +
		`encounter_id = $1, admitted = $2, admission_date = $3, discharge_date = $4, remark = $5, enter_by = $6, enter_on = $7 ` +
		`WHERE id = $8`
	// run
	logf(sqlstr, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn, xa.ID)
	if _, err := db.ExecContext(ctx, sqlstr, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn, xa.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [XAdmission] to the database.
func (xa *XAdmission) Save(ctx context.Context, db DB) error {
	if xa.Exists() {
		return xa.Update(ctx, db)
	}
	return xa.Insert(ctx, db)
}

// Upsert performs an upsert for [XAdmission].
func (xa *XAdmission) Upsert(ctx context.Context, db DB) error {
	switch {
	case xa._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.x_admission (` +
		`id, encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`encounter_id = EXCLUDED.encounter_id, admitted = EXCLUDED.admitted, admission_date = EXCLUDED.admission_date, discharge_date = EXCLUDED.discharge_date, remark = EXCLUDED.remark, enter_by = EXCLUDED.enter_by, enter_on = EXCLUDED.enter_on `
	// run
	logf(sqlstr, xa.ID, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn)
	if _, err := db.ExecContext(ctx, sqlstr, xa.ID, xa.EncounterID, xa.Admitted, xa.AdmissionDate, xa.DischargeDate, xa.Remark, xa.EnterBy, xa.EnterOn); err != nil {
		return logerror(err)
	}
	// set exists
	xa._exists = true
	return nil
}

// Delete deletes the [XAdmission] from the database.
func (xa *XAdmission) Delete(ctx context.Context, db DB) error {
	switch {
	case !xa._exists: // doesn't exist
		return nil
	case xa._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.x_admission ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, xa.ID)
	if _, err := db.ExecContext(ctx, sqlstr, xa.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	xa._deleted = true
	return nil
}

// XAdmissionByID retrieves a row from 'public.x_admission' as a [XAdmission].
//
// Generated from index 'admission_pkey'.
func XAdmissionByID(ctx context.Context, db DB, id int) (*XAdmission, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, encounter_id, admitted, admission_date, discharge_date, remark, enter_by, enter_on ` +
		`FROM public.x_admission ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	xa := XAdmission{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&xa.ID, &xa.EncounterID, &xa.Admitted, &xa.AdmissionDate, &xa.DischargeDate, &xa.Remark, &xa.EnterBy, &xa.EnterOn); err != nil {
		return nil, logerror(err)
	}
	return &xa, nil
}
