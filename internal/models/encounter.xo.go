package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Encounter represents a row from 'public.encounter'.
type Encounter struct {
	EncounterID   int            `json:"encounter_id"`   // encounter_id
	EncounterType sql.NullInt64  `json:"encounter_type"` // encounter_type
	EncounterTime sql.NullString `json:"encounter_time"` // encounter_time
	ClientID      sql.NullInt64  `json:"client_id"`      // client_id
	EncounterDate sql.NullString `json:"encounter_date"` // encounter_date
	ManagedBy     sql.NullInt64  `json:"managed_by"`     // managed_by
	EnterOn       sql.NullTime   `json:"enter_on"`       // enter_on
	EnterBy       sql.NullInt64  `json:"enter_by"`       // enter_by
	ClinicalTeam  sql.NullString `json:"clinical_team"`  // clinical_team
	OutbreakID    sql.NullInt64  `json:"outbreak_id"`    // outbreak_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Encounter] exists in the database.
func (e *Encounter) Exists() bool {
	return e._exists
}

// Deleted returns true when the [Encounter] has been marked for deletion
// from the database.
func (e *Encounter) Deleted() bool {
	return e._deleted
}

// Insert inserts the [Encounter] to the database.
func (e *Encounter) Insert(ctx context.Context, db DB) error {
	switch {
	case e._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case e._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.encounter (` +
		`encounter_type, encounter_time, client_id, encounter_date, managed_by, enter_on, enter_by, clinical_team, outbreak_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING encounter_id`
	// run
	logf(sqlstr, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID)
	if err := db.QueryRowContext(ctx, sqlstr, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID).Scan(&e.EncounterID); err != nil {
		return logerror(err)
	}
	// set exists
	e._exists = true
	return nil
}

// Update updates a [Encounter] in the database.
func (e *Encounter) Update(ctx context.Context, db DB) error {
	switch {
	case !e._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case e._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.encounter SET ` +
		`encounter_type = $1, encounter_time = $2, client_id = $3, encounter_date = $4, managed_by = $5, enter_on = $6, enter_by = $7, clinical_team = $8, outbreak_id = $9 ` +
		`WHERE encounter_id = $10`
	// run
	logf(sqlstr, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID, e.EncounterID)
	if _, err := db.ExecContext(ctx, sqlstr, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID, e.EncounterID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Encounter] to the database.
func (e *Encounter) Save(ctx context.Context, db DB) error {
	if e.Exists() {
		return e.Update(ctx, db)
	}
	return e.Insert(ctx, db)
}

// Upsert performs an upsert for [Encounter].
func (e *Encounter) Upsert(ctx context.Context, db DB) error {
	switch {
	case e._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.encounter (` +
		`encounter_id, encounter_type, encounter_time, client_id, encounter_date, managed_by, enter_on, enter_by, clinical_team, outbreak_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (encounter_id) DO ` +
		`UPDATE SET ` +
		`encounter_type = EXCLUDED.encounter_type, encounter_time = EXCLUDED.encounter_time, client_id = EXCLUDED.client_id, encounter_date = EXCLUDED.encounter_date, managed_by = EXCLUDED.managed_by, enter_on = EXCLUDED.enter_on, enter_by = EXCLUDED.enter_by, clinical_team = EXCLUDED.clinical_team, outbreak_id = EXCLUDED.outbreak_id `
	// run
	logf(sqlstr, e.EncounterID, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID)
	if _, err := db.ExecContext(ctx, sqlstr, e.EncounterID, e.EncounterType, e.EncounterTime, e.ClientID, e.EncounterDate, e.ManagedBy, e.EnterOn, e.EnterBy, e.ClinicalTeam, e.OutbreakID); err != nil {
		return logerror(err)
	}
	// set exists
	e._exists = true
	return nil
}

// Delete deletes the [Encounter] from the database.
func (e *Encounter) Delete(ctx context.Context, db DB) error {
	switch {
	case !e._exists: // doesn't exist
		return nil
	case e._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.encounter ` +
		`WHERE encounter_id = $1`
	// run
	logf(sqlstr, e.EncounterID)
	if _, err := db.ExecContext(ctx, sqlstr, e.EncounterID); err != nil {
		return logerror(err)
	}
	// set deleted
	e._deleted = true
	return nil
}

// EncounterByEncounterID retrieves a row from 'public.encounter' as a [Encounter].
//
// Generated from index 'encounter_pkey1'.
func EncounterByEncounterID(ctx context.Context, db DB, encounterID int) (*Encounter, error) {
	// query
	const sqlstr = `SELECT ` +
		`encounter_id, encounter_type, encounter_time, client_id, encounter_date, managed_by, enter_on, enter_by, clinical_team, outbreak_id ` +
		`FROM public.encounter ` +
		`WHERE encounter_id = $1`
	// run
	logf(sqlstr, encounterID)
	e := Encounter{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, encounterID).Scan(&e.EncounterID, &e.EncounterType, &e.EncounterTime, &e.ClientID, &e.EncounterDate, &e.ManagedBy, &e.EnterOn, &e.EnterBy, &e.ClinicalTeam, &e.OutbreakID); err != nil {
		return nil, logerror(err)
	}
	return &e, nil
}
