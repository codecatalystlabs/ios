package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Client represents a row from 'public.clients'.
type Client struct {
	ID               int             `json:"id"`                 // id
	UUID             sql.NullString  `json:"uuid"`               // uuid
	Firstname        sql.NullString  `json:"firstname"`          // firstname
	Lastname         sql.NullString  `json:"lastname"`           // lastname
	Othername        sql.NullString  `json:"othername"`          // othername
	Gender           sql.NullInt64   `json:"gender"`             // gender
	DateOfBirth      sql.NullString  `json:"date_of_birth"`      // date_of_birth
	Age              sql.NullFloat64 `json:"age"`                // age
	Marital          sql.NullInt64   `json:"marital"`            // marital
	Nin              sql.NullString  `json:"nin"`                // nin
	Nationality      sql.NullInt64   `json:"nationality"`        // nationality
	AdmDate          sql.NullString  `json:"adm_date"`           // adm_date
	AdmFrom          sql.NullString  `json:"adm_from"`           // adm_from
	LabNo            sql.NullString  `json:"lab_no"`             // lab_no
	CifNo            sql.NullString  `json:"cif_no"`             // cif_no
	EtuNo            sql.NullString  `json:"etu_no"`             // etu_no
	CaseNo           sql.NullString  `json:"case_no"`            // case_no
	Occupation       sql.NullInt64   `json:"occupation"`         // occupation
	OccupationAza    sql.NullString  `json:"occupation_aza"`     // occupation_aza
	DateSymptomOnset sql.NullString  `json:"date_symptom_onset"` // date_symptom_onset
	DateIsolation    sql.NullString  `json:"date_isolation"`     // date_isolation
	Pregnant         sql.NullInt64   `json:"pregnant"`           // pregnant
	AdmWard          sql.NullString  `json:"adm_ward"`           // adm_ward
	Tb               sql.NullInt64   `json:"tb"`                 // tb
	Asplenia         sql.NullInt64   `json:"asplenia"`           // asplenia
	Hep              sql.NullInt64   `json:"hep"`                // hep
	Diabetes         sql.NullInt64   `json:"diabetes"`           // diabetes
	Hiv              sql.NullInt64   `json:"hiv"`                // hiv
	Liver            sql.NullInt64   `json:"liver"`              // liver
	Malignancy       sql.NullInt64   `json:"malignancy"`         // malignancy
	Heart            sql.NullInt64   `json:"heart"`              // heart
	Pulmonary        sql.NullInt64   `json:"pulmonary"`          // pulmonary
	Kidney           sql.NullInt64   `json:"kidney"`             // kidney
	Neurologic       sql.NullInt64   `json:"neurologic"`         // neurologic
	Other            sql.NullString  `json:"other"`              // other
	Status           sql.NullString  `json:"status"`             // status
	EnterOn          sql.NullTime    `json:"enter_on"`           // enter_on
	EnterBy          sql.NullInt64   `json:"enter_by"`           // enter_by
	EditOn           sql.NullTime    `json:"edit_on"`            // edit_on
	EditBy           sql.NullInt64   `json:"edit_by"`            // edit_by
	Transfer         sql.NullInt64   `json:"transfer"`           // transfer
	Site             sql.NullInt64   `json:"site"`               // site
	OutbreakID       sql.NullInt64   `json:"outbreak_id"`        // outbreak_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Client] exists in the database.
func (c *Client) Exists() bool {
	return c._exists
}

// Deleted returns true when the [Client] has been marked for deletion
// from the database.
func (c *Client) Deleted() bool {
	return c._deleted
}

// Insert inserts the [Client] to the database.
func (c *Client) Insert(ctx context.Context, db DB) error {
	switch {
	case c._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case c._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.clients (` +
		`uuid, firstname, lastname, othername, gender, date_of_birth, age, marital, nin, nationality, adm_date, adm_from, lab_no, cif_no, etu_no, case_no, occupation, occupation_aza, date_symptom_onset, date_isolation, pregnant, adm_ward, tb, asplenia, hep, diabetes, hiv, liver, malignancy, heart, pulmonary, kidney, neurologic, other, status, enter_on, enter_by, edit_on, edit_by, transfer, site, outbreak_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42` +
		`) RETURNING id`
	// run
	logf(sqlstr, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID)
	if err := db.QueryRowContext(ctx, sqlstr, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID).Scan(&c.ID); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Update updates a [Client] in the database.
func (c *Client) Update(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case c._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.clients SET ` +
		`uuid = $1, firstname = $2, lastname = $3, othername = $4, gender = $5, date_of_birth = $6, age = $7, marital = $8, nin = $9, nationality = $10, adm_date = $11, adm_from = $12, lab_no = $13, cif_no = $14, etu_no = $15, case_no = $16, occupation = $17, occupation_aza = $18, date_symptom_onset = $19, date_isolation = $20, pregnant = $21, adm_ward = $22, tb = $23, asplenia = $24, hep = $25, diabetes = $26, hiv = $27, liver = $28, malignancy = $29, heart = $30, pulmonary = $31, kidney = $32, neurologic = $33, other = $34, status = $35, enter_on = $36, enter_by = $37, edit_on = $38, edit_by = $39, transfer = $40, site = $41, outbreak_id = $42 ` +
		`WHERE id = $43`
	// run
	logf(sqlstr, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID, c.ID)
	if _, err := db.ExecContext(ctx, sqlstr, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID, c.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Client] to the database.
func (c *Client) Save(ctx context.Context, db DB) error {
	if c.Exists() {
		return c.Update(ctx, db)
	}
	return c.Insert(ctx, db)
}

// Upsert performs an upsert for [Client].
func (c *Client) Upsert(ctx context.Context, db DB) error {
	switch {
	case c._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.clients (` +
		`id, uuid, firstname, lastname, othername, gender, date_of_birth, age, marital, nin, nationality, adm_date, adm_from, lab_no, cif_no, etu_no, case_no, occupation, occupation_aza, date_symptom_onset, date_isolation, pregnant, adm_ward, tb, asplenia, hep, diabetes, hiv, liver, malignancy, heart, pulmonary, kidney, neurologic, other, status, enter_on, enter_by, edit_on, edit_by, transfer, site, outbreak_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40, $41, $42, $43` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`uuid = EXCLUDED.uuid, firstname = EXCLUDED.firstname, lastname = EXCLUDED.lastname, othername = EXCLUDED.othername, gender = EXCLUDED.gender, date_of_birth = EXCLUDED.date_of_birth, age = EXCLUDED.age, marital = EXCLUDED.marital, nin = EXCLUDED.nin, nationality = EXCLUDED.nationality, adm_date = EXCLUDED.adm_date, adm_from = EXCLUDED.adm_from, lab_no = EXCLUDED.lab_no, cif_no = EXCLUDED.cif_no, etu_no = EXCLUDED.etu_no, case_no = EXCLUDED.case_no, occupation = EXCLUDED.occupation, occupation_aza = EXCLUDED.occupation_aza, date_symptom_onset = EXCLUDED.date_symptom_onset, date_isolation = EXCLUDED.date_isolation, pregnant = EXCLUDED.pregnant, adm_ward = EXCLUDED.adm_ward, tb = EXCLUDED.tb, asplenia = EXCLUDED.asplenia, hep = EXCLUDED.hep, diabetes = EXCLUDED.diabetes, hiv = EXCLUDED.hiv, liver = EXCLUDED.liver, malignancy = EXCLUDED.malignancy, heart = EXCLUDED.heart, pulmonary = EXCLUDED.pulmonary, kidney = EXCLUDED.kidney, neurologic = EXCLUDED.neurologic, other = EXCLUDED.other, status = EXCLUDED.status, enter_on = EXCLUDED.enter_on, enter_by = EXCLUDED.enter_by, edit_on = EXCLUDED.edit_on, edit_by = EXCLUDED.edit_by, transfer = EXCLUDED.transfer, site = EXCLUDED.site, outbreak_id = EXCLUDED.outbreak_id `
	// run
	logf(sqlstr, c.ID, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID)
	if _, err := db.ExecContext(ctx, sqlstr, c.ID, c.UUID, c.Firstname, c.Lastname, c.Othername, c.Gender, c.DateOfBirth, c.Age, c.Marital, c.Nin, c.Nationality, c.AdmDate, c.AdmFrom, c.LabNo, c.CifNo, c.EtuNo, c.CaseNo, c.Occupation, c.OccupationAza, c.DateSymptomOnset, c.DateIsolation, c.Pregnant, c.AdmWard, c.Tb, c.Asplenia, c.Hep, c.Diabetes, c.Hiv, c.Liver, c.Malignancy, c.Heart, c.Pulmonary, c.Kidney, c.Neurologic, c.Other, c.Status, c.EnterOn, c.EnterBy, c.EditOn, c.EditBy, c.Transfer, c.Site, c.OutbreakID); err != nil {
		return logerror(err)
	}
	// set exists
	c._exists = true
	return nil
}

// Delete deletes the [Client] from the database.
func (c *Client) Delete(ctx context.Context, db DB) error {
	switch {
	case !c._exists: // doesn't exist
		return nil
	case c._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.clients ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, c.ID)
	if _, err := db.ExecContext(ctx, sqlstr, c.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	c._deleted = true
	return nil
}

// ClientByID retrieves a row from 'public.clients' as a [Client].
//
// Generated from index 'clients_pkey'.
func ClientByID(ctx context.Context, db DB, id int) (*Client, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, uuid, firstname, lastname, othername, gender, date_of_birth, age, marital, nin, nationality, adm_date, adm_from, lab_no, cif_no, etu_no, case_no, occupation, occupation_aza, date_symptom_onset, date_isolation, pregnant, adm_ward, tb, asplenia, hep, diabetes, hiv, liver, malignancy, heart, pulmonary, kidney, neurologic, other, status, enter_on, enter_by, edit_on, edit_by, transfer, site, outbreak_id ` +
		`FROM public.clients ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	c := Client{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&c.ID, &c.UUID, &c.Firstname, &c.Lastname, &c.Othername, &c.Gender, &c.DateOfBirth, &c.Age, &c.Marital, &c.Nin, &c.Nationality, &c.AdmDate, &c.AdmFrom, &c.LabNo, &c.CifNo, &c.EtuNo, &c.CaseNo, &c.Occupation, &c.OccupationAza, &c.DateSymptomOnset, &c.DateIsolation, &c.Pregnant, &c.AdmWard, &c.Tb, &c.Asplenia, &c.Hep, &c.Diabetes, &c.Hiv, &c.Liver, &c.Malignancy, &c.Heart, &c.Pulmonary, &c.Kidney, &c.Neurologic, &c.Other, &c.Status, &c.EnterOn, &c.EnterBy, &c.EditOn, &c.EditBy, &c.Transfer, &c.Site, &c.OutbreakID); err != nil {
		return nil, logerror(err)
	}
	return &c, nil
}
