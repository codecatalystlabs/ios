package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// XEncounter represents a row from 'public.x_encounter'.
type XEncounter struct {
	ID            int             `json:"id"`             // id
	EnrollmentID  sql.NullInt64   `json:"enrollment_id"`  // enrollment_id
	EncounterType sql.NullInt64   `json:"encounter_type"` // encounter_type
	Date          sql.NullTime    `json:"date"`           // date
	Temp          sql.NullFloat64 `json:"temp"`           // temp
	HeartRate     sql.NullFloat64 `json:"heart_rate"`     // heart_rate
	RespRate      sql.NullFloat64 `json:"resp_rate"`      // resp_rate
	BpSys         sql.NullFloat64 `json:"bp_sys"`         // bp_sys
	BpDia         sql.NullFloat64 `json:"bp_dia"`         // bp_dia
	Dehydration   sql.NullInt64   `json:"dehydration"`    // dehydration
	Alertness     sql.NullInt64   `json:"alertness"`      // alertness
	Height        sql.NullFloat64 `json:"height"`         // height
	Weight        sql.NullFloat64 `json:"weight"`         // weight
	EnterBy       sql.NullInt64   `json:"enter_by"`       // enter_by
	EnterOn       sql.NullTime    `json:"enter_on"`       // enter_on
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [XEncounter] exists in the database.
func (xe *XEncounter) Exists() bool {
	return xe._exists
}

// Deleted returns true when the [XEncounter] has been marked for deletion
// from the database.
func (xe *XEncounter) Deleted() bool {
	return xe._deleted
}

// Insert inserts the [XEncounter] to the database.
func (xe *XEncounter) Insert(ctx context.Context, db DB) error {
	switch {
	case xe._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case xe._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.x_encounter (` +
		`enrollment_id, encounter_type, date, temp, heart_rate, resp_rate, bp_sys, bp_dia, dehydration, alertness, height, weight, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14` +
		`) RETURNING id`
	// run
	logf(sqlstr, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn)
	if err := db.QueryRowContext(ctx, sqlstr, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn).Scan(&xe.ID); err != nil {
		return logerror(err)
	}
	// set exists
	xe._exists = true
	return nil
}

// Update updates a [XEncounter] in the database.
func (xe *XEncounter) Update(ctx context.Context, db DB) error {
	switch {
	case !xe._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case xe._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.x_encounter SET ` +
		`enrollment_id = $1, encounter_type = $2, date = $3, temp = $4, heart_rate = $5, resp_rate = $6, bp_sys = $7, bp_dia = $8, dehydration = $9, alertness = $10, height = $11, weight = $12, enter_by = $13, enter_on = $14 ` +
		`WHERE id = $15`
	// run
	logf(sqlstr, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn, xe.ID)
	if _, err := db.ExecContext(ctx, sqlstr, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn, xe.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [XEncounter] to the database.
func (xe *XEncounter) Save(ctx context.Context, db DB) error {
	if xe.Exists() {
		return xe.Update(ctx, db)
	}
	return xe.Insert(ctx, db)
}

// Upsert performs an upsert for [XEncounter].
func (xe *XEncounter) Upsert(ctx context.Context, db DB) error {
	switch {
	case xe._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.x_encounter (` +
		`id, enrollment_id, encounter_type, date, temp, heart_rate, resp_rate, bp_sys, bp_dia, dehydration, alertness, height, weight, enter_by, enter_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`enrollment_id = EXCLUDED.enrollment_id, encounter_type = EXCLUDED.encounter_type, date = EXCLUDED.date, temp = EXCLUDED.temp, heart_rate = EXCLUDED.heart_rate, resp_rate = EXCLUDED.resp_rate, bp_sys = EXCLUDED.bp_sys, bp_dia = EXCLUDED.bp_dia, dehydration = EXCLUDED.dehydration, alertness = EXCLUDED.alertness, height = EXCLUDED.height, weight = EXCLUDED.weight, enter_by = EXCLUDED.enter_by, enter_on = EXCLUDED.enter_on `
	// run
	logf(sqlstr, xe.ID, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn)
	if _, err := db.ExecContext(ctx, sqlstr, xe.ID, xe.EnrollmentID, xe.EncounterType, xe.Date, xe.Temp, xe.HeartRate, xe.RespRate, xe.BpSys, xe.BpDia, xe.Dehydration, xe.Alertness, xe.Height, xe.Weight, xe.EnterBy, xe.EnterOn); err != nil {
		return logerror(err)
	}
	// set exists
	xe._exists = true
	return nil
}

// Delete deletes the [XEncounter] from the database.
func (xe *XEncounter) Delete(ctx context.Context, db DB) error {
	switch {
	case !xe._exists: // doesn't exist
		return nil
	case xe._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.x_encounter ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, xe.ID)
	if _, err := db.ExecContext(ctx, sqlstr, xe.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	xe._deleted = true
	return nil
}

// XEncounterByID retrieves a row from 'public.x_encounter' as a [XEncounter].
//
// Generated from index 'encounter_pkey'.
func XEncounterByID(ctx context.Context, db DB, id int) (*XEncounter, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, enrollment_id, encounter_type, date, temp, heart_rate, resp_rate, bp_sys, bp_dia, dehydration, alertness, height, weight, enter_by, enter_on ` +
		`FROM public.x_encounter ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	xe := XEncounter{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&xe.ID, &xe.EnrollmentID, &xe.EncounterType, &xe.Date, &xe.Temp, &xe.HeartRate, &xe.RespRate, &xe.BpSys, &xe.BpDia, &xe.Dehydration, &xe.Alertness, &xe.Height, &xe.Weight, &xe.EnterBy, &xe.EnterOn); err != nil {
		return nil, logerror(err)
	}
	return &xe, nil
}
