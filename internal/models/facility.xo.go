package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Facility represents a row from 'public.facility'.
type Facility struct {
	FacilityID    int            `json:"facility_id"`    // facility_id
	FacilityName  sql.NullString `json:"facility_name"`  // facility_name
	FacilityLevel sql.NullInt64  `json:"facility_level"` // facility_level
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Facility] exists in the database.
func (f *Facility) Exists() bool {
	return f._exists
}

// Deleted returns true when the [Facility] has been marked for deletion
// from the database.
func (f *Facility) Deleted() bool {
	return f._deleted
}

// Insert inserts the [Facility] to the database.
func (f *Facility) Insert(ctx context.Context, db DB) error {
	switch {
	case f._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case f._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.facility (` +
		`facility_name, facility_level` +
		`) VALUES (` +
		`$1, $2` +
		`) RETURNING facility_id`
	// run
	logf(sqlstr, f.FacilityName, f.FacilityLevel)
	if err := db.QueryRowContext(ctx, sqlstr, f.FacilityName, f.FacilityLevel).Scan(&f.FacilityID); err != nil {
		return logerror(err)
	}
	// set exists
	f._exists = true
	return nil
}

// Update updates a [Facility] in the database.
func (f *Facility) Update(ctx context.Context, db DB) error {
	switch {
	case !f._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case f._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.facility SET ` +
		`facility_name = $1, facility_level = $2 ` +
		`WHERE facility_id = $3`
	// run
	logf(sqlstr, f.FacilityName, f.FacilityLevel, f.FacilityID)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacilityName, f.FacilityLevel, f.FacilityID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Facility] to the database.
func (f *Facility) Save(ctx context.Context, db DB) error {
	if f.Exists() {
		return f.Update(ctx, db)
	}
	return f.Insert(ctx, db)
}

// Upsert performs an upsert for [Facility].
func (f *Facility) Upsert(ctx context.Context, db DB) error {
	switch {
	case f._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.facility (` +
		`facility_id, facility_name, facility_level` +
		`) VALUES (` +
		`$1, $2, $3` +
		`)` +
		` ON CONFLICT (facility_id) DO ` +
		`UPDATE SET ` +
		`facility_name = EXCLUDED.facility_name, facility_level = EXCLUDED.facility_level `
	// run
	logf(sqlstr, f.FacilityID, f.FacilityName, f.FacilityLevel)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacilityID, f.FacilityName, f.FacilityLevel); err != nil {
		return logerror(err)
	}
	// set exists
	f._exists = true
	return nil
}

// Delete deletes the [Facility] from the database.
func (f *Facility) Delete(ctx context.Context, db DB) error {
	switch {
	case !f._exists: // doesn't exist
		return nil
	case f._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.facility ` +
		`WHERE facility_id = $1`
	// run
	logf(sqlstr, f.FacilityID)
	if _, err := db.ExecContext(ctx, sqlstr, f.FacilityID); err != nil {
		return logerror(err)
	}
	// set deleted
	f._deleted = true
	return nil
}

// FacilityByFacilityID retrieves a row from 'public.facility' as a [Facility].
//
// Generated from index 'facility_pkey'.
func FacilityByFacilityID(ctx context.Context, db DB, facilityID int) (*Facility, error) {
	// query
	const sqlstr = `SELECT ` +
		`facility_id, facility_name, facility_level ` +
		`FROM public.facility ` +
		`WHERE facility_id = $1`
	// run
	logf(sqlstr, facilityID)
	f := Facility{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, facilityID).Scan(&f.FacilityID, &f.FacilityName, &f.FacilityLevel); err != nil {
		return nil, logerror(err)
	}
	return &f, nil
}
