// Package models contains generated code for schema 'public'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// ActiveCase represents a row from 'public.active_case'.
type ActiveCase struct {
	ID        int            `json:"id"`         // id
	Facility  sql.NullString `json:"facility"`   // facility
	Date      sql.NullString `json:"date"`       // date
	Officer   sql.NullString `json:"officer"`    // officer
	Q1        sql.NullInt64  `json:"q1"`         // q1
	Q2        sql.NullInt64  `json:"q2"`         // q2
	Q3        sql.NullInt64  `json:"q3"`         // q3
	Q4        sql.NullInt64  `json:"q4"`         // q4
	Q5        sql.NullInt64  `json:"q5"`         // q5
	Q6        sql.NullInt64  `json:"q6"`         // q6
	Q7        sql.NullInt64  `json:"q7"`         // q7
	Q8        sql.NullInt64  `json:"q8"`         // q8
	EnteredBy sql.NullInt64  `json:"entered_by"` // entered_by
	EnteredOn sql.NullString `json:"entered_on"` // entered_on
	UpdatedBy sql.NullInt64  `json:"updated_by"` // updated_by
	UpdatedOn sql.NullString `json:"updated_on"` // updated_on
	Status    sql.NullInt64  `json:"status"`     // status
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [ActiveCase] exists in the database.
func (ac *ActiveCase) Exists() bool {
	return ac._exists
}

// Deleted returns true when the [ActiveCase] has been marked for deletion
// from the database.
func (ac *ActiveCase) Deleted() bool {
	return ac._deleted
}

// Insert inserts the [ActiveCase] to the database.
func (ac *ActiveCase) Insert(ctx context.Context, db DB) error {
	switch {
	case ac._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ac._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.active_case (` +
		`facility, date, officer, q1, q2, q3, q4, q5, q6, q7, q8, entered_by, entered_on, updated_by, updated_on, status` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16` +
		`) RETURNING id`
	// run
	logf(sqlstr, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status)
	if err := db.QueryRowContext(ctx, sqlstr, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status).Scan(&ac.ID); err != nil {
		return logerror(err)
	}
	// set exists
	ac._exists = true
	return nil
}

// Update updates a [ActiveCase] in the database.
func (ac *ActiveCase) Update(ctx context.Context, db DB) error {
	switch {
	case !ac._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ac._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.active_case SET ` +
		`facility = $1, date = $2, officer = $3, q1 = $4, q2 = $5, q3 = $6, q4 = $7, q5 = $8, q6 = $9, q7 = $10, q8 = $11, entered_by = $12, entered_on = $13, updated_by = $14, updated_on = $15, status = $16 ` +
		`WHERE id = $17`
	// run
	logf(sqlstr, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status, ac.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status, ac.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [ActiveCase] to the database.
func (ac *ActiveCase) Save(ctx context.Context, db DB) error {
	if ac.Exists() {
		return ac.Update(ctx, db)
	}
	return ac.Insert(ctx, db)
}

// Upsert performs an upsert for [ActiveCase].
func (ac *ActiveCase) Upsert(ctx context.Context, db DB) error {
	switch {
	case ac._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.active_case (` +
		`id, facility, date, officer, q1, q2, q3, q4, q5, q6, q7, q8, entered_by, entered_on, updated_by, updated_on, status` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`facility = EXCLUDED.facility, date = EXCLUDED.date, officer = EXCLUDED.officer, q1 = EXCLUDED.q1, q2 = EXCLUDED.q2, q3 = EXCLUDED.q3, q4 = EXCLUDED.q4, q5 = EXCLUDED.q5, q6 = EXCLUDED.q6, q7 = EXCLUDED.q7, q8 = EXCLUDED.q8, entered_by = EXCLUDED.entered_by, entered_on = EXCLUDED.entered_on, updated_by = EXCLUDED.updated_by, updated_on = EXCLUDED.updated_on, status = EXCLUDED.status `
	// run
	logf(sqlstr, ac.ID, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status)
	if _, err := db.ExecContext(ctx, sqlstr, ac.ID, ac.Facility, ac.Date, ac.Officer, ac.Q1, ac.Q2, ac.Q3, ac.Q4, ac.Q5, ac.Q6, ac.Q7, ac.Q8, ac.EnteredBy, ac.EnteredOn, ac.UpdatedBy, ac.UpdatedOn, ac.Status); err != nil {
		return logerror(err)
	}
	// set exists
	ac._exists = true
	return nil
}

// Delete deletes the [ActiveCase] from the database.
func (ac *ActiveCase) Delete(ctx context.Context, db DB) error {
	switch {
	case !ac._exists: // doesn't exist
		return nil
	case ac._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.active_case ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, ac.ID)
	if _, err := db.ExecContext(ctx, sqlstr, ac.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	ac._deleted = true
	return nil
}

// ActiveCaseByID retrieves a row from 'public.active_case' as a [ActiveCase].
//
// Generated from index 'active_case_pkey'.
func ActiveCaseByID(ctx context.Context, db DB, id int) (*ActiveCase, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, facility, date, officer, q1, q2, q3, q4, q5, q6, q7, q8, entered_by, entered_on, updated_by, updated_on, status ` +
		`FROM public.active_case ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	ac := ActiveCase{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&ac.ID, &ac.Facility, &ac.Date, &ac.Officer, &ac.Q1, &ac.Q2, &ac.Q3, &ac.Q4, &ac.Q5, &ac.Q6, &ac.Q7, &ac.Q8, &ac.EnteredBy, &ac.EnteredOn, &ac.UpdatedBy, &ac.UpdatedOn, &ac.Status); err != nil {
		return nil, logerror(err)
	}
	return &ac, nil
}
