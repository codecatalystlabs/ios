package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Discharge represents a row from 'public.discharge'.
type Discharge struct {
	DischargeID           int            `json:"discharge_id"`             // discharge_id
	ClientID              sql.NullInt64  `json:"client_id"`                // client_id
	DischargeDate         sql.NullString `json:"discharge_date"`           // discharge_date
	FinalDiagnosis        sql.NullString `json:"final_diagnosis"`          // final_diagnosis
	FinalDiagnosisOther   sql.NullString `json:"final_diagnosis_other"`    // final_diagnosis_other
	DischargeOutcome      sql.NullString `json:"discharge_outcome"`        // discharge_outcome
	DischargeSeqHeari     sql.NullInt64  `json:"discharge_seq_heari"`      // discharge_seq_heari
	DischargeSeqPregn     sql.NullInt64  `json:"discharge_seq_pregn"`      // discharge_seq_pregn
	DischargeSeqOcula     sql.NullInt64  `json:"discharge_seq_ocula"`      // discharge_seq_ocula
	DischargeSeqExtre     sql.NullInt64  `json:"discharge_seq_extre"`      // discharge_seq_extre
	DischargeSeqArthr     sql.NullInt64  `json:"discharge_seq_arthr"`      // discharge_seq_arthr
	DischargeSeqNeuro     sql.NullInt64  `json:"discharge_seq_neuro"`      // discharge_seq_neuro
	DischargeSeqOthers    sql.NullInt64  `json:"discharge_seq_others"`     // discharge_seq_others
	CounsellingProvided   sql.NullString `json:"counselling_provided"`     // counselling_provided
	DischargingOfficer    sql.NullString `json:"discharging_officer"`      // discharging_officer
	DischargeFacility     sql.NullString `json:"discharge_facility"`       // discharge_facility
	DischargeSeqOthersAza sql.NullString `json:"discharge_seq_others_aza"` // discharge_seq_others_aza
	EnteredOn             sql.NullString `json:"entered_on"`               // entered_on
	EnteredBy             sql.NullInt64  `json:"entered_by"`               // entered_by
	UpdatedBy             sql.NullInt64  `json:"updated_by"`               // updated_by
	UpdatedOn             sql.NullString `json:"updated_on"`               // updated_on
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Discharge] exists in the database.
func (d *Discharge) Exists() bool {
	return d._exists
}

// Deleted returns true when the [Discharge] has been marked for deletion
// from the database.
func (d *Discharge) Deleted() bool {
	return d._deleted
}

// Insert inserts the [Discharge] to the database.
func (d *Discharge) Insert(ctx context.Context, db DB) error {
	switch {
	case d._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case d._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.discharge (` +
		`client_id, discharge_date, final_diagnosis, final_diagnosis_other, discharge_outcome, discharge_seq_heari, discharge_seq_pregn, discharge_seq_ocula, discharge_seq_extre, discharge_seq_arthr, discharge_seq_neuro, discharge_seq_others, counselling_provided, discharging_officer, discharge_facility, discharge_seq_others_aza, entered_on, entered_by, updated_by, updated_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20` +
		`) RETURNING discharge_id`
	// run
	logf(sqlstr, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn)
	if err := db.QueryRowContext(ctx, sqlstr, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn).Scan(&d.DischargeID); err != nil {
		return logerror(err)
	}
	// set exists
	d._exists = true
	return nil
}

// Update updates a [Discharge] in the database.
func (d *Discharge) Update(ctx context.Context, db DB) error {
	switch {
	case !d._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case d._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.discharge SET ` +
		`client_id = $1, discharge_date = $2, final_diagnosis = $3, final_diagnosis_other = $4, discharge_outcome = $5, discharge_seq_heari = $6, discharge_seq_pregn = $7, discharge_seq_ocula = $8, discharge_seq_extre = $9, discharge_seq_arthr = $10, discharge_seq_neuro = $11, discharge_seq_others = $12, counselling_provided = $13, discharging_officer = $14, discharge_facility = $15, discharge_seq_others_aza = $16, entered_on = $17, entered_by = $18, updated_by = $19, updated_on = $20 ` +
		`WHERE discharge_id = $21`
	// run
	logf(sqlstr, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn, d.DischargeID)
	if _, err := db.ExecContext(ctx, sqlstr, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn, d.DischargeID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Discharge] to the database.
func (d *Discharge) Save(ctx context.Context, db DB) error {
	if d.Exists() {
		return d.Update(ctx, db)
	}
	return d.Insert(ctx, db)
}

// Upsert performs an upsert for [Discharge].
func (d *Discharge) Upsert(ctx context.Context, db DB) error {
	switch {
	case d._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.discharge (` +
		`discharge_id, client_id, discharge_date, final_diagnosis, final_diagnosis_other, discharge_outcome, discharge_seq_heari, discharge_seq_pregn, discharge_seq_ocula, discharge_seq_extre, discharge_seq_arthr, discharge_seq_neuro, discharge_seq_others, counselling_provided, discharging_officer, discharge_facility, discharge_seq_others_aza, entered_on, entered_by, updated_by, updated_on` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21` +
		`)` +
		` ON CONFLICT (discharge_id) DO ` +
		`UPDATE SET ` +
		`client_id = EXCLUDED.client_id, discharge_date = EXCLUDED.discharge_date, final_diagnosis = EXCLUDED.final_diagnosis, final_diagnosis_other = EXCLUDED.final_diagnosis_other, discharge_outcome = EXCLUDED.discharge_outcome, discharge_seq_heari = EXCLUDED.discharge_seq_heari, discharge_seq_pregn = EXCLUDED.discharge_seq_pregn, discharge_seq_ocula = EXCLUDED.discharge_seq_ocula, discharge_seq_extre = EXCLUDED.discharge_seq_extre, discharge_seq_arthr = EXCLUDED.discharge_seq_arthr, discharge_seq_neuro = EXCLUDED.discharge_seq_neuro, discharge_seq_others = EXCLUDED.discharge_seq_others, counselling_provided = EXCLUDED.counselling_provided, discharging_officer = EXCLUDED.discharging_officer, discharge_facility = EXCLUDED.discharge_facility, discharge_seq_others_aza = EXCLUDED.discharge_seq_others_aza, entered_on = EXCLUDED.entered_on, entered_by = EXCLUDED.entered_by, updated_by = EXCLUDED.updated_by, updated_on = EXCLUDED.updated_on `
	// run
	logf(sqlstr, d.DischargeID, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn)
	if _, err := db.ExecContext(ctx, sqlstr, d.DischargeID, d.ClientID, d.DischargeDate, d.FinalDiagnosis, d.FinalDiagnosisOther, d.DischargeOutcome, d.DischargeSeqHeari, d.DischargeSeqPregn, d.DischargeSeqOcula, d.DischargeSeqExtre, d.DischargeSeqArthr, d.DischargeSeqNeuro, d.DischargeSeqOthers, d.CounsellingProvided, d.DischargingOfficer, d.DischargeFacility, d.DischargeSeqOthersAza, d.EnteredOn, d.EnteredBy, d.UpdatedBy, d.UpdatedOn); err != nil {
		return logerror(err)
	}
	// set exists
	d._exists = true
	return nil
}

// Delete deletes the [Discharge] from the database.
func (d *Discharge) Delete(ctx context.Context, db DB) error {
	switch {
	case !d._exists: // doesn't exist
		return nil
	case d._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.discharge ` +
		`WHERE discharge_id = $1`
	// run
	logf(sqlstr, d.DischargeID)
	if _, err := db.ExecContext(ctx, sqlstr, d.DischargeID); err != nil {
		return logerror(err)
	}
	// set deleted
	d._deleted = true
	return nil
}

// DischargeByDischargeID retrieves a row from 'public.discharge' as a [Discharge].
//
// Generated from index 'discharge_pkey'.
func DischargeByDischargeID(ctx context.Context, db DB, dischargeID int) (*Discharge, error) {
	// query
	const sqlstr = `SELECT ` +
		`discharge_id, client_id, discharge_date, final_diagnosis, final_diagnosis_other, discharge_outcome, discharge_seq_heari, discharge_seq_pregn, discharge_seq_ocula, discharge_seq_extre, discharge_seq_arthr, discharge_seq_neuro, discharge_seq_others, counselling_provided, discharging_officer, discharge_facility, discharge_seq_others_aza, entered_on, entered_by, updated_by, updated_on ` +
		`FROM public.discharge ` +
		`WHERE discharge_id = $1`
	// run
	logf(sqlstr, dischargeID)
	d := Discharge{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, dischargeID).Scan(&d.DischargeID, &d.ClientID, &d.DischargeDate, &d.FinalDiagnosis, &d.FinalDiagnosisOther, &d.DischargeOutcome, &d.DischargeSeqHeari, &d.DischargeSeqPregn, &d.DischargeSeqOcula, &d.DischargeSeqExtre, &d.DischargeSeqArthr, &d.DischargeSeqNeuro, &d.DischargeSeqOthers, &d.CounsellingProvided, &d.DischargingOfficer, &d.DischargeFacility, &d.DischargeSeqOthersAza, &d.EnteredOn, &d.EnteredBy, &d.UpdatedBy, &d.UpdatedOn); err != nil {
		return nil, logerror(err)
	}
	return &d, nil
}
