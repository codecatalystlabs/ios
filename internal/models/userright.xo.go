package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// UserRight represents a row from 'public.user_right'.
type UserRight struct {
	UserRightsID        int           `json:"user_rights_id"`         // user_rights_id
	UserID              sql.NullInt64 `json:"user_id"`                // user_id
	FunctionScope       sql.NullInt64 `json:"function_scope"`         // function_scope
	UserRightsFunction  sql.NullInt64 `json:"user_rights_function"`   // user_rights_function
	UserRightsCanCreate sql.NullInt64 `json:"user_rights_can_create"` // user_rights_can_create
	UserRightsCanView   sql.NullInt64 `json:"user_rights_can_view"`   // user_rights_can_view
	UserRightsCanEdit   sql.NullInt64 `json:"user_rights_can_edit"`   // user_rights_can_edit
	UserRightsCanRemove sql.NullInt64 `json:"user_rights_can_remove"` // user_rights_can_remove
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [UserRight] exists in the database.
func (ur *UserRight) Exists() bool {
	return ur._exists
}

// Deleted returns true when the [UserRight] has been marked for deletion
// from the database.
func (ur *UserRight) Deleted() bool {
	return ur._deleted
}

// Insert inserts the [UserRight] to the database.
func (ur *UserRight) Insert(ctx context.Context, db DB) error {
	switch {
	case ur._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case ur._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.user_right (` +
		`user_id, function_scope, user_rights_function, user_rights_can_create, user_rights_can_view, user_rights_can_edit, user_rights_can_remove` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`) RETURNING user_rights_id`
	// run
	logf(sqlstr, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove)
	if err := db.QueryRowContext(ctx, sqlstr, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove).Scan(&ur.UserRightsID); err != nil {
		return logerror(err)
	}
	// set exists
	ur._exists = true
	return nil
}

// Update updates a [UserRight] in the database.
func (ur *UserRight) Update(ctx context.Context, db DB) error {
	switch {
	case !ur._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case ur._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.user_right SET ` +
		`user_id = $1, function_scope = $2, user_rights_function = $3, user_rights_can_create = $4, user_rights_can_view = $5, user_rights_can_edit = $6, user_rights_can_remove = $7 ` +
		`WHERE user_rights_id = $8`
	// run
	logf(sqlstr, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove, ur.UserRightsID)
	if _, err := db.ExecContext(ctx, sqlstr, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove, ur.UserRightsID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [UserRight] to the database.
func (ur *UserRight) Save(ctx context.Context, db DB) error {
	if ur.Exists() {
		return ur.Update(ctx, db)
	}
	return ur.Insert(ctx, db)
}

// Upsert performs an upsert for [UserRight].
func (ur *UserRight) Upsert(ctx context.Context, db DB) error {
	switch {
	case ur._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.user_right (` +
		`user_rights_id, user_id, function_scope, user_rights_function, user_rights_can_create, user_rights_can_view, user_rights_can_edit, user_rights_can_remove` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (user_rights_id) DO ` +
		`UPDATE SET ` +
		`user_id = EXCLUDED.user_id, function_scope = EXCLUDED.function_scope, user_rights_function = EXCLUDED.user_rights_function, user_rights_can_create = EXCLUDED.user_rights_can_create, user_rights_can_view = EXCLUDED.user_rights_can_view, user_rights_can_edit = EXCLUDED.user_rights_can_edit, user_rights_can_remove = EXCLUDED.user_rights_can_remove `
	// run
	logf(sqlstr, ur.UserRightsID, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove)
	if _, err := db.ExecContext(ctx, sqlstr, ur.UserRightsID, ur.UserID, ur.FunctionScope, ur.UserRightsFunction, ur.UserRightsCanCreate, ur.UserRightsCanView, ur.UserRightsCanEdit, ur.UserRightsCanRemove); err != nil {
		return logerror(err)
	}
	// set exists
	ur._exists = true
	return nil
}

// Delete deletes the [UserRight] from the database.
func (ur *UserRight) Delete(ctx context.Context, db DB) error {
	switch {
	case !ur._exists: // doesn't exist
		return nil
	case ur._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.user_right ` +
		`WHERE user_rights_id = $1`
	// run
	logf(sqlstr, ur.UserRightsID)
	if _, err := db.ExecContext(ctx, sqlstr, ur.UserRightsID); err != nil {
		return logerror(err)
	}
	// set deleted
	ur._deleted = true
	return nil
}

// UserRightByUserRightsID retrieves a row from 'public.user_right' as a [UserRight].
//
// Generated from index 'user_right_pkey'.
func UserRightByUserRightsID(ctx context.Context, db DB, userRightsID int) (*UserRight, error) {
	// query
	const sqlstr = `SELECT ` +
		`user_rights_id, user_id, function_scope, user_rights_function, user_rights_can_create, user_rights_can_view, user_rights_can_edit, user_rights_can_remove ` +
		`FROM public.user_right ` +
		`WHERE user_rights_id = $1`
	// run
	logf(sqlstr, userRightsID)
	ur := UserRight{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, userRightsID).Scan(&ur.UserRightsID, &ur.UserID, &ur.FunctionScope, &ur.UserRightsFunction, &ur.UserRightsCanCreate, &ur.UserRightsCanView, &ur.UserRightsCanEdit, &ur.UserRightsCanRemove); err != nil {
		return nil, logerror(err)
	}
	return &ur, nil
}
